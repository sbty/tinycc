# パート 18: 左辺値と右辺値の見直し

先立つものがない中で作業を勧めているので、時々既存のコードを消して書き直し、より汎用的にしたり欠点を修正する必要が有ります。今回もそれに当たります。

パート15でポインタのサポートを追加したので次のようなコードが書けます。

```c
  int  x;
  int *y;
  int  z;
  x= 12; y= &x; z= *y;
```

これで問題ありませんが、いずれ代入文の左辺でポインタの利用をサポートする必要がでてくることがわかっています。

```c
*y = 14;
```

これを行うには、左辺値と右辺値を見直す必要が有ります。復習すると、左辺値は特定の場所と結びついた値であり、右辺値はそうではありません。左辺値はその後の命令で値を取り出すことができきる、永続的な値が入っています。一方で右辺値は儚いものであり、一度用途を終えたら捨てることができます。

## 左辺値と右辺値の例

右辺値の例は23のような整数文字列とします。これを式に使い、その後捨てることができます。左辺値の例はメモリ内の場所であり、保存先で次のようなものです。

```c
   a            スカラ変数a
   b[0]         配列bの0番目の要素
   *c           ポインタcの指す先の位置
   (*d)[0]      dが指す先の配列の0番目の要素
```

以前言及したように左辺値と右辺値の名前は代入文の両端に由来します。左にあるから左辺値、右側にあるから右辺値です。

## 左辺値の概念の拡張

今現在コンパイラはほぼ全てを右辺値として処理しています。変数について変数の位置から値を取り出しています。左辺値の概念への唯一の手がかりは代入の左にある識別子をA_LVIDENTとしてマークすることです。これを`genAST()`で手動で処理します。

```c
    case A_IDENT:
      return (cgloadglob(n->v.id));
    case A_LVIDENT:
      return (cgstorglob(reg, n->v.id));
    case A_ASSIGN:
      // やるべきことはやったので結果を返す
      return (rightreg);
```

`a=b`のような文に使います。しかしこれからは代入の左にある識別子以外にも左辺値としてマークする必要が有ります。

またその過程でアセンブリコードの生成を容易にすることも重要です。このパートを書いているときにツリーの親として"A_LVALUE" ASTノードを前置きして、コードジェネレータに右辺値の代わりにコードの左辺値バージョンを生成させるアイデアを試しました。ですがこれはあまりに遅すぎました。サブツリーはすでに評価され、対応する右辺値のコードは生成されていました。

## ASTノードへのさらなる変更

ASTノードにフィールドを追加し続けるのは避けたいのですが、結局次のようになりました。ノードが左辺値のコードを生成するのか、あるいは右辺値のコードを精製するのかを示すフィールドを用意しました。

```c
// Abstract Syntax Tree structure
struct ASTnode {
  int op;                       // このツリーに対して実行される"操作"
  int type;                     // このツリーが生成する式の型
  int rvalue;                   // ノードが右辺値であればtrue
  ...
};
```

`rvalue`フィールドは1ビットの情報しかありません。後に他真偽値を保存する必要がでたらこれをビットフィールドとして利用する予定です。

疑問: なぜこのフィールドをノードの"左辺値"ではなく右辺値を示すようにしたのでしょうか？ 結局の所、ASTツリーのノードの殆どは左辺>値ではなく右辺値を持っています。Nils HolmのSubCに関する本を呼んでいると、次の行を見つけました。

> 間接参照は取り消すことができないのでパーサはそれぞれの部分式を左辺値とみなす。

パーサが式`b=a+2`を見ているケースを考えます。識別子`b`をパースした後、これが左辺値か右辺値か伝えることができません。左辺値であると決定できる`=`トークンを見つけるまでは不可能です。

また、C言語は代入を式として扱えるので、`b=c=a+2`と記述することも可能です。ここでも識別子`a`をパースするとき、次のトークンをパースするまでこれが左辺値であるか右辺値であるか伝えることができません。

従って、各ASTノードをデフォルトで左辺値であるとみなす選択をしました。ノードが右辺値であると確実に言えるときは、`rvalue`フィールドにそれを示すよう値をセットします。

## 代入式

C言語では代入を式として扱えることに言及しました。左辺値と右辺値の区別が明確になったので代入のパースを式に移行し、コードを式のパーサに移せるようになりました。これについては後で説明します。

これらを実現するためにコンパイラにどういったことを行ったのか確認します。いつもどおりトークンとスキャナーから始めます。

## トークンとスキャンの変更

今回追加されたトークンやキーワードはありません。ですがトークンコードへ影響する変更は有ります。`=`は両側に式を持つ二項演算子になったので他二項演算子と統合する必要が有ります。

[C言語のオペレータリスト](https://en.cppreference.com/w/c/language/operator_precedence)によれば、`=`演算子は`+`や`-`よりもずっと低い優先度になっています。演算子とその優先順位のリストを並び替える必要が有ります。`defs.h`です。

```c
// Token types
enum {
  T_EOF,
  // Operators
  T_ASSIGN,
  T_PLUS, T_MINUS, ...
```

`expr.c`で二項演算子の優先順位を保持するコードを更新しなければなりません。

```c
// それぞれのトークンの演算子優先順位。
// defs.hのトークンの並びと一致している必要がある。
static int OpPrec[] = {
   0, 10,                       // T_EOF,  T_ASSIGN
  20, 20,                       // T_PLUS, T_MINUS
  30, 30,                       // T_STAR, T_SLASH
  40, 40,                       // T_EQ, T_NE
  50, 50, 50, 50                // T_LT, T_GT, T_LE, T_GE
};
```
