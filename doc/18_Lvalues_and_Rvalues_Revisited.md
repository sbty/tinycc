# パート 18: 左辺値と右辺値の見直し

先立つものがない中で作業を勧めているので、時々既存のコードを消して書き直し、より汎用的にしたり欠点を修正する必要が有ります。今回もそれに当たります。

パート15でポインタのサポートを追加したので次のようなコードが書けます。

```c
  int  x;
  int *y;
  int  z;
  x= 12; y= &x; z= *y;
```

これで問題ありませんが、いずれ代入文の左辺でポインタの利用をサポートする必要がでてくることがわかっています。

```c
*y = 14;
```

これを行うには、左辺値と右辺値を見直す必要が有ります。復習すると、左辺値は特定の場所と結びついた値であり、右辺値はそうではありません。左辺値はその後の命令で値を取り出すことができきる、永続的な値が入っています。一方で右辺値は儚いものであり、一度用途を終えたら捨てることができます。

## 左辺値と右辺値の例

右辺値の例は23のような整数文字列とします。これを式に使い、その後捨てることができます。左辺値の例はメモリ内の場所であり、保存先で次のようなものです。

```c
   a            スカラ変数a
   b[0]         配列bの0番目の要素
   *c           ポインタcの指す先の位置
   (*d)[0]      dが指す先の配列の0番目の要素
```

以前言及したように左辺値と右辺値の名前は代入文の両端に由来します。左にあるから左辺値、右側にあるから右辺値です。

## 左辺値の概念の拡張

今現在コンパイラはほぼ全てを右辺値として処理しています。変数について変数の位置から値を取り出しています。左辺値の概念への唯一の手がかりは代入の左にある識別子をA_LVIDENTとしてマークすることです。これを`genAST()`で手動で処理します。

```c
    case A_IDENT:
      return (cgloadglob(n->v.id));
    case A_LVIDENT:
      return (cgstorglob(reg, n->v.id));
    case A_ASSIGN:
      // やるべきことはやったので結果を返す
      return (rightreg);
```

`a=b`のような文に使います。しかしこれからは代入の左にある識別子以外にも左辺値としてマークする必要が有ります。

またその過程でアセンブリコードの生成を容易にすることも重要です。このパートを書いているときにツリーの親として"A_LVALUE" ASTノードを前置きして、コードジェネレータに右辺値の代わりにコードの左辺値バージョンを生成させるアイデアを試しました。ですがこれはあまりに遅すぎました。サブツリーはすでに評価され、対応する右辺値のコードは生成されていました。

## ASTノードへのさらなる変更

ASTノードにフィールドを追加し続けるのは避けたいのですが、結局次のようになりました。ノードが左辺値のコードを生成するのか、あるいは右辺値のコードを精製するのかを示すフィールドを用意しました。

```c
// Abstract Syntax Tree structure
struct ASTnode {
  int op;                       // このツリーに対して実行される"操作"
  int type;                     // このツリーが生成する式の型
  int rvalue;                   // ノードが右辺値であればtrue
  ...
};
```

`rvalue`フィールドは1ビットの情報しかありません。後に他真偽値を保存する必要がでたらこれをビットフィールドとして利用する予定です。

疑問: なぜこのフィールドをノードの"左辺値"ではなく右辺値を示すようにしたのでしょうか？ 結局の所、ASTツリーのノードの殆どは左辺>値ではなく右辺値を持っています。Nils HolmのSubCに関する本を呼んでいると、次の行を見つけました。

> 間接参照は取り消すことができないのでパーサはそれぞれの部分式を左辺値とみなす。

パーサが式`b=a+2`を見ているケースを考えます。識別子`b`をパースした後、これが左辺値か右辺値か伝えることができません。左辺値であると決定できる`=`トークンを見つけるまでは不可能です。

また、C言語は代入を式として扱えるので、`b=c=a+2`と記述することも可能です。ここでも識別子`a`をパースするとき、次のトークンをパースするまでこれが左辺値であるか右辺値であるか伝えることができません。

従って、各ASTノードをデフォルトで左辺値であるとみなす選択をしました。ノードが右辺値であると確実に言えるときは、`rvalue`フィールドにそれを示すよう値をセットします。

## 代入式

C言語では代入を式として扱えることに言及しました。左辺値と右辺値の区別が明確になったので代入のパースを式に移行し、コードを式のパーサに移せるようになりました。これについては後で説明します。

これらを実現するためにコンパイラにどういったことを行ったのか確認します。いつもどおりトークンとスキャナーから始めます。

## トークンとスキャンの変更

今回追加されたトークンやキーワードはありません。ですがトークンコードへ影響する変更は有ります。`=`は両側に式を持つ二項演算子になったので他二項演算子と統合する必要が有ります。

[C言語のオペレータリスト](https://en.cppreference.com/w/c/language/operator_precedence)によれば、`=`演算子は`+`や`-`よりもずっと低い優先度になっています。演算子とその優先順位のリストを並び替える必要が有ります。`defs.h`です。

```c
// Token types
enum {
  T_EOF,
  // Operators
  T_ASSIGN,
  T_PLUS, T_MINUS, ...
```

`expr.c`で二項演算子の優先順位を保持するコードを更新しなければなりません。

```c
// それぞれのトークンの演算子優先順位。
// defs.hのトークンの並びと一致している必要がある。
static int OpPrec[] = {
   0, 10,                       // T_EOF,  T_ASSIGN
  20, 20,                       // T_PLUS, T_MINUS
  30, 30,                       // T_STAR, T_SLASH
  40, 40,                       // T_EQ, T_NE
  50, 50, 50, 50                // T_LT, T_GT, T_LE, T_GE
};
```

## パーサへの変更

ステートメントとみなしている代入のパースを取り除き、式とする必要が有ります。また、`printint()`を呼び出せるようになったので言語から"print"ステートメントを削除しました。というわけで、`stmt.c`では`print_statement()`と`assignment_statement()`の両方を削除しました。

> またT_PRINTとprintキーワードも削除しました。左辺値と右辺値のコンセプトも違うためA_LVIDENT ASTノード型も削除しました。

とりあえず`stmt.c`にある`single_statement()`は最初のトークンを認識しないのであれば、次にくるものが式であるとみなすようになっています。

```c
static struct ASTnode *single_statement(void) {
  int type;

  switch (Token.token) {
    ...
    default:
    // 取り合えすこれが式であるか確認する
    // ここで代入ステートメントを補足する
    return (binexpr(0));
  }
}
```

これは`2+3;`を問題ないステートメントとして処理されます。後に修正します。そして`compound_statement()`で式の後ろにセミコロンがあるか確認します。

```c
    // 一部のステートメントは後ろにセミコロンが必須
    if (tree != NULL && (tree->op == A_ASSIGN ||
                         tree->op == A_RETURN || tree->op == A_FUNCCALL))
      semi();
```

## 式のパース

`=`は二項演算子としてマークされ、その優先順位を設定したのでやることを終えたと思われるかもしれません。しかしそうではありません。2つ懸念事項が残っています。

1. 左辺値のコードよりも右辺値のコードを先にアセンブリで生成する必要が有ります。これはステートメントパーサで行っていましたが、式パーサでやることになるでしょう。
2. 代入式は右結合です。オペレータは左よりも右側の式と強く結びつきます。

これまで右結合について触れてきませんでした。例を見ていきます。式`2+3+4`があります。これは左から右へ問題なくパースしASTツリーを構築できます。

```c
      +
     / \
    +   4
   / \
  2   3
```

式`a=b=3`を見てみます。上記と同様にすると、次のようなツリーとなります。

```c
      =
     / \
    =   3
   / \
  a   b
```

左側のサブツリーに3を代入する前に`a=b`をしたくありません。代わりに、生成したいものは次のようなツリーです。

```c
        =
       / \
      =   a
     / \
    3   b
```

アセンブリの出力順になるようにはノードを逆にしました。最初に`b`に3を保存します。それからこの代入の結果である3を`a`に保存します。

### プラット(Pratt)パーサの修正

二項演算子の優先順位を適切にパースするため、プラットパーサを使用しています。プラットパーサに右接合を追加する方法を見つけ出すために調査を行い、[wikipedia](https://en.wikipedia.org/wiki/Operator-precedence_parser)で次の情報を見つけました。

> 見据えているものはopよりも優先度の高い二項演算子、あるいはopと等しい優先順位である右結合オペレータ

というわけで、右結合オペレータでは次のオペレータが直前のオペレータと同じ優先順位であるかテストします。これはパーサロジックへのかんたんな修正です。`expr.c`に新しい関数を導入し、オペレータが右結合か判断するようにしました。

```c
// トークンが右結合であればtrue、そうでなければfalseを返す
static int rightassoc(int tokentype) {
  if (tokentype == T_ASSIGN)
    return(1);
  return(0);
}
```

`binexpr()`では前述したようにwhileループを変更し、更にA_ASSIGN固有のコードを入れて子ツリーを入れ替えるようにします。

```c
struct ASTnode *binexpr(int ptp) {
  struct ASTnode *left, *right;
  struct ASTnode *ltemp, *rtemp;
  int ASTop;
  int tokentype;

  // 左にあるツリーを取得
  left = prefix();
  ...

  // このトークンの優先順位が直前のものより高いか、
  // 右結合で直前のトークンの優先順位と等しい限りループする
   while ((op_precedence(tokentype) > ptp) ||
         (rightassoc(tokentype) && op_precedence(tokentype) == ptp)) {
    ...
    // 再帰的にbinexpr()にトークンの優先順位を渡して呼び出し
    // サブツリーを構築する
    right = binexpr(OpPrec[tokentype]);

    ASTop = binastop(tokentype);
    if (ASTop == A_ASSIGN) {
      // 代入
      // 右側のツリーを右辺値に入れる
      right->rvalue= 1;
      ...

      // leftとrightを切り替えて右の式のコードが
      // 左の式より先に生成されるようにする
      ltemp= left; left= right; right= ltemp;
    } else {
      // 代入は行わないので両ツリーは右辺値となる
      left->rvalue= 1;
      right->rvalue= 1;
    }
    ...
  }
  ...
}
```

代入式の右側を右辺地として明示的にマークするコードに注目してください。そして代入出ない場合は式の両サイドは右辺値としてマークされます。

`binexpr()`には明示的にツリーを右辺値とセットする数行のコードが散らばっています。これらは葉ノードに入ると実行されます。例えば`b=a`にある識別子aは右辺値としてマークされる必要がありますですが、それをするためのwhileループのボディへ入ることはありません。
