# 11 関数 パート1

関数の実装を包めていきますが、多くのステップに分ける必要があるでしょう。次のような課題が有ります。

- データ型: `char` `int` `long`など
- 関数の戻り値
- 関数への引数の数
- ローカルで関数に渡される変数とグローバル変数の区別

このパートで終わらせるにはあまりに多くの仕事があります。ですからここでは関数の宣言をするところまで進めます。出来上がった実行形式は`main()`関数のみが動くでしょうが、やがて複数の関数のコードを生成できる機能がつくでしょう。

うまく行けばこのコンパイラが認識する言語はCのサブセット相当となり、入力は"本物の"Cコンパイラーで認識できるものとなるでしょう。ですがまだまだです。

## 単純化した関数構文

関数的ななにかをパースできるように、後で間違いなく変更を加えることになります。これを終えると、方や戻り値型、引数といった重要なものに取り掛かることができます。

今の時点ではBNFで言えば次のようになる関数文法を追加するつもりです。

`function_declaration: 'void' identifier '(' ')' compound_statement   ;`

すべての関数は戻り値`void`、引数なしで宣言されます。呼び出すこともできないので`main()`関数のみが実行されます。

新しくキーワード`void`とトークンT_VOIDを追加します。これは簡単です。

## 単純化した関数構文のパース

関数構文はとても単純で、パースに必要な関数をスッキリ小さく記述できます(`decl.c`)。

```c
// 単純化した関数の宣言をパースする
struct ASTnode *function_declaration(void) {
  struct ASTnode *tree;
  int nameslot;

  // 'void'、識別子(関数名)'('と')'を探す
  // いまは見つけても何もしない
  match(T_VOID, "void");
  ident();
  nameslot= addglob(Text);
  lparen();
  rparen();

  // 合成ステートメントのASTツリーを取得
  tree= compound_statement();

  // 関数の名前枠と合成ステートメントのサブツリーを持つA_FUNCTIONノードを返す
  return(mkastunary(A_FUNCTION, tree, nameslot));
}
```

これは構文チェックとASTの構築をしますが、意味解釈のエラーチェックはほとんどしていません。関数が再宣言された場合は今はまだ気が付きません。
