# パート17: 型チェックの改良とポインタオフセット

少し前のパートで、ポインタを実装し型の互換性をチェックするコードを実装しました。その時は次のようなコードに

```c
  int   c;
  int  *e;

  e= &c + 1;
```

`&c`のポインタに1を加算するには`c`のサイズに変換され、メモリ上`c`の後ろにある次の`int`まで確実にスキップする必要があります。つまり整数型をスケールする必要が有ります。

これをポインタでも行う必要が有り、後で配列にも必要となります。次のコードを考えます。

```c
  int list[10];
  int x= list[3];
```

これを行うには`list[]`の初期アドレスを見つけ、それからインデックス位置3にある要素を見つけるために`int`のサイズを3回加算する必要が有ります。

このときは2つの型に互換性があるか判断する`type_compatible()`という関数を`type.c`に用意し、大きな整数型と同じサイズにするために小さな型を拡張する必要がある場合は明記するようにしていました。ただしこの拡張は別の場所で行っていました。実際コンパイラでは3箇所で処理することで実現しています。

## `type_compatible()`の置き換え

`type_compatible()`が示すのであれば、ツリーを大きな整数型にマッチするようA_WIDENするでしょう。現在はツリーを値が型のサイズでスケールされるようA_SCALEする必要が有ります。拡張コードの重複をリファクタリングしたいです。

そのために`type_compatible()`を捨てて置き換えました。かなり考えることがあり、おそらく再度改善や拡張が必要となるでしょう。設計を見ていきます。

既存の`type_compatible()`:

- 2つの型の値を引数にとり、オプションで向きもある
- 型に互換性があればtrueを返す
- 一方を拡張する必要があればA_WIDENを返す
- ツリーにはA_WIDENノードを繋げない
- 型に互換性がなければfalseを返す
- ポインタ型を扱わない

型の比較の利用例を見ていきます。:

- 2つの式に二項演算子を適用する場合、型に互換性はあるのか、拡張、拡縮は必要か
- `print`文を実行する場合、式は整数で拡張は必要か
- 代入文を実行する場合、式を拡張する必要はあるか、左辺値の型に一致しているか
- `return`文を実行する場合、式を拡張する必要はあるか、関数の戻り値の型に一致しているか

この例で2つの式があるのは1つだけです。したがって1つのASTツリーと変換先の型を引数に取る関数を新しく用意しました。二項演算子の例ではこの関数を2回呼び出し、それぞれでなにが起こるか確認します。
