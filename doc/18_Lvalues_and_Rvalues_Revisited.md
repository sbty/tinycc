# パート 18: 左辺値と右辺値の見直し

先立つものがない中で作業を勧めているので、時々既存のコードを消して書き直し、より汎用的にしたり欠点を修正する必要が有ります。今回もそれに当たります。

パート15でポインタのサポートを追加したので次のようなコードが書けます。

```c
  int  x;
  int *y;
  int  z;
  x= 12; y= &x; z= *y;
```

これで問題ありませんが、いずれ代入文の左辺でポインタの利用をサポートする必要がでてくることがわかっています。

```c
*y = 14;
```

これを行うには、左辺値と右辺値を見直す必要が有ります。復習すると、左辺値は特定の場所と結びついた値であり、右辺値はそうではありません。左辺値はその後の命令で値を取り出すことができきる、永続的な値が入っています。一方で右辺値は儚いものであり、一度用途を終えたら捨てることができます。

## 左辺値と右辺値の例

右辺値の例は23のような整数文字列とします。これを式に使い、その後捨てることができます。左辺値の例はメモリ内の場所であり、保存先で次のようなものです。

```c
   a            スカラ変数a
   b[0]         配列bの0番目の要素
   *c           ポインタcの指す先の位置
   (*d)[0]      dが指す先の配列の0番目の要素
```

以前言及したように左辺値と右辺値の名前は代入文の両端に由来します。左にあるから左辺値、右側にあるから右辺値です。

## 左辺値の概念の拡張

今現在コンパイラはほぼ全てを右辺値として処理しています。変数について変数の位置から値を取り出しています。左辺値の概念への唯一の手がかりは代入の左にある識別子をA_LVIDENTとしてマークすることです。これを`genAST()`で手動で処理します。

```c
    case A_IDENT:
      return (cgloadglob(n->v.id));
    case A_LVIDENT:
      return (cgstorglob(reg, n->v.id));
    case A_ASSIGN:
      // やるべきことはやったので結果を返す
      return (rightreg);
```

`a=b`のような文に使います。しかしこれからは代入の左にある識別子以外にも左辺値としてマークする必要が有ります。

またその過程でアセンブリコードの生成を容易にすることも重要です。このパートを書いているときにツリーの親として"A_LVALUE" ASTノードを前置きして、コードジェネレータに右辺値の代わりにコードの左辺値バージョンを生成させるアイデアを試しました。ですがこれはあまりに遅すぎました。サブツリーはすでに評価され、対応する右辺値のコードは生成されていました。
