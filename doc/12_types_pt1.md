# 12 型 パート1

今の所、かなり簡略化した関数宣言だけがあります。コンパイラへ型の追加をはじめようと思います。

## どの型から始めるか?

グローバル変数での`char`と`int`から始めます。関数にはすでに`void`キーワードを追加してあります。次は関数の返り値を追加します。いまのところ`void`はあるのですが、完全に処理してるわけではありません。

明らかに`char`は`int`よりもずっと制限された値です。SubCのように`char`の範囲を0〜255とし、、`int`は符号付き値の範囲にするつもりです。

つまり`char`の値を`int`に拡張することができますが、`int`の値を`char`の範囲に狭める際には、開発者に警告しなければなりません。

## 追加するキーワードとトークン

'char'キーワードとT_CHARトークンだけ追加します。

## 式の型

今後はすべての式に型が付きます。

- 整数リテラル、例えば56は`int`
- 計算式、例えば45-12は`int`
- 変数、`x`を`char`として宣言したのであれば、右辺値は`char`

式を必要に応じて拡張したり、必要であれば狭めるのを拒否するため、式を評価するのであればそれぞれの式の型を追跡する必要があるでしょう。

SubCコンパイラではNilは単一の左辺値構造体を生成しました。この構造体を指すポインタが再帰パーサに渡され、パースが指す地点の式の型を追跡しています。

ここでは違う手法を試みます。抽象構文ツリーを修正し、ある地点でのツリーの型を保持する、`type`フィールドを用意します。`defs.h`に追加した型は以下のとおりです。

```c
// 基本となる型
enum {
  P_NONE, P_VOID, P_CHAR, P_INT
};
```

いい名前が思いつかなかったのでSubCではNilsと呼んでいたものを、基本となる型(primitive types)としました。P_NONE値はASTノードが式を表さず、型がないことを示します。例としてA_GLUEノード型はステートメントをつなげるものですが、左側のステートメントが生成されると、型については言及がありません。

`tree.c`を見ると、ASTノードを構築する関数が、ASTノード構造体に追加されたtypeフィールドに代入するよう修正されていることがわかります。

```c
struct ASTnode {
  int op;                       // このツリーに対して実行される"操作"
  int type;                     // このツリーが生成する式の型
  ...
};
```
